"""

## Problem 924: Minimum malware spread

## Author: Neha Doiphode
## Date:   11-13-2022

## Description:
    You are given a network of n nodes represented as an n x n adjacency matrix graph,
    where the ith node is directly connected to the jth node if graph[i][j] == 1.

    Some nodes initial are initially infected by malware.
    Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware,
    both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

    Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.
    We will remove exactly one node from initial.

    Return the node that, if removed, would minimize M(initial).
    If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

    Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.

# Examples:
    Example 1:
        Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
        Output: 0

    Example 2:
        Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
        Output: 0

    Example 3:
        Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
        Output: 1

 ## Constraints:
    n == graph.length
    n == graph[i].length
    2 <= n <= 300
    graph[i][j] is 0 or 1.
    graph[i][j] == graph[j][i]
    graph[i][i] == 1
    1 <= initial.length <= n
    0 <= initial[i] <= n - 1
    All the integers in initial are unique.

## Algorithm:

    Example:
        Input:
            0   1   2   3   4   5   6   7   8   9

        0   1   1   0   0   0   0   0   0   0   0
        1   1   1   0   0   0   0   0   0   0   0
        2   0   0   1   0   0   0   0   1   0   0
        3   0   0   0   1   0   0   0   0   1   0
        4   0   0   0   0   1   1   0   0   0   0
        5   0   0   0   0   1   1   1   0   0   0
        6   0   0   0   0   0   1   1   0   1   0
        7   0   0   1   0   0   0   0   1   0   1
        8   0   0   0   1   0   0   1   0   1   0
        9   0   0   0   0   0   0   0   1   0   1


        Connected Nodes     Assigned colors for grouping

        4 - 5 - 6 - 8 - 3 ===== Color 2

        2 - 7 - 9 ========= Color 1

        0 - 1     ========= Color 0

        5, 8, 7, 1 ====== Initial

    1. Take array with all nodes, initialized to -1.
        0   1   2   3   4   5   6   7   8   9
        -1  -1  -1  -1  -1  -1  -1  -1  -1  -1

    2. Perform DFS and find all connected nodes to the starting node.
       Assign a color or grouping name to all the nodes connected to each other.

    3. We perform 3 DFSs. Increment the color after each DFS.
       0    1   2   3    4   5   6   7   8   9   colors array
       0    0   -1  -1  -1  -1  -1  -1  -1  -1   DFS on color 0 nodes
       0    0    1  -1  -1  -1  -1   1  -1   1   DFS on color 1 nodes
       0    0    1   2   2   2   2   1   2   1   DFS on color 2 nodes

    4. Create groups array and count nodes of each color.
       0    1   2  ==== Colors
       2    3   5  ==== Counts

    5. Find out how many nodes in each group are already infected. Create
       infected array.
       Go over initial array, pick the infected node, go to colors array, find
       out which color the node belongs to and go to infected arrays index and
       add one there.

       5    8    7   1 ====== Initial

       0    1    2   3   4   5   6   7   8   9  ==== indices
       0    0    1   2   2   2   2   1   2   1  ==== Colors

       0    1   2   ==== groups
       1    1   2   ==== Infected nodes per group


    6. Now, iterate over each node in initial array.
       Find out the group each node belongs to and how many infected nodes and total nodes the group has.
       Based on total nodes and infected node count in the group, we can find out which node to remove from the initial
       set.

       answer = float("inf")
       initial = 5, 8, 7, 1

       Node 5 belongs to group 2. Group 2 has total 5 nodes out of which 2 are infected. So if we remove 1 of the two,
       the other will still infect the whole group.

       Node 8 also belongs to group 2 so same applies to node 8 as well.

       Node 7 belongs to group 1 which has total 3 nodes and 1 of them is infected. So if we remove 7 from initial we
       can save 3 nodes. So at this point we can update the answer as index of 7 in the initial array.
       answer = min(answer, index of node in initial) = 2

       Node 1 belongs to group 0 which has total 2 nodes and 1 of them is infected so if we remove 1 infected node from
       initial, we will still be able to only save 2 nodes which is NOT better then the answer we have already found.

       So our final answer is index 2 which is node 7 from initial array.

## Time Complexity: O(N^2), where N is the length of graph,
                    as the graph is given in adjacency matrix form, we have to go over every row and column and perform DFS for N nodes.
                    So O(N) to traverse each node and O(N) to perform the DFS where we traverse the matrix row wise.

## Space Complexity: O(N), to store groups array and other supporting arrays that are used in the solution.

"""

from typing import List, Optional
from collections import Counter

def get_input():
    print("Enter the number of rows/columns in graph represented by the adjacency matrix: ", end = "")
    rows = int(input())
    cols = rows
    graph = []
    graph = [[-1 for _ in range(cols)] for _ in range(rows)]

    print("Enter the connections in the graph(0 or 1): ")
    for row in range(rows):
        for col in range(cols):
            print(f"graph[{row}][{col}] = ", end = "")
            graph[row][col] = int(input())


    print("Enter the list of initial infected nodes(int with spaces): ", end = "")
    initial = input()
    initial = [int(node) for node in initial.split()]
    return graph, initial

class Solution:
    groups = []

    def dfs(self, graph: List[List[int]], group_color: int, starting_node: int) -> None:
        # base case
        if self.groups[starting_node] != -1:
            return

        # logic
        self.groups[starting_node] = group_color

        for j in range(len(graph)):
            if graph[starting_node][j] == 1:
                self.dfs(graph, group_color, j)

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        if len(graph) == 0 or len(initial) == 0:
            return None

        answer = float("inf")
        saved_nodes = -float("inf")

        # Declare colors array as class variable
        self.groups = [-1 for _ in range(len(graph))]

        # We need to iterate over the graph and perform DFS to group the connected nodes together.
        n = len(graph)
        starting_node = -1
        group_color = 0

        for i in range(n):
            if self.groups[i] == -1:
                starting_node = i
                self.dfs(graph, group_color, starting_node)
                group_color += 1

        # Once we have colors assigned to different nodes,
        # we need to count total number of nodes belonging to each group
        total_nodes_per_group = [0 for _ in range(group_color)]
        for node in self.groups:
            total_nodes_per_group[node] += 1

        # Once we have total counts for each color,
        # now we count number of infected nodes belonging to each group.
        infected_nodes_per_group = [0 for _ in range(len(total_nodes_per_group))]
        for node in initial:
            infected_nodes_per_group[self.groups[node]] += 1

        # Now go over initial, find group of the node,
        # then find total number of nodes in the group that initial node belongs to
        # also, find number of infected nodes in the same group and find out how many nodes we can save.
        for index, node in enumerate(initial):
            group_of_node = self.groups[node]
            total_nodes_in_group = total_nodes_per_group[group_of_node]
            infected_nodes_in_group = infected_nodes_per_group[group_of_node]

            if infected_nodes_in_group == 1:
                # Check if answer was ever set
                if answer == float("inf"):
                    answer = node

                # if total number of nodes that can be saved is greater for the current node
                # as compared to the nodes that can be saved with answer, then we have to update the answer.
                elif total_nodes_in_group > total_nodes_per_group[self.groups[answer]]:
                    answer = node

                # if nodes that can be saved are same for the answer and current node,
                # then we go for the lower node.
                elif total_nodes_in_group == total_nodes_per_group[self.groups[answer]] and answer > initial[index]:
                    answer = node

        # If there is no group exists where we can simply remove 1 node from infected and can save other nodes,
        # we just return the minimum node in the list of initial nodes as per the problem statement
        if answer == float("inf"):
            for index in range(len(initial)):
                answer = min(answer, initial[index])
        return answer

# Driver code
solution = Solution()
graph, initial = get_input()
print(f"Input: Graph: {graph}")
print(f"Input: Initial infected nodes: {initial}")
print(f"Output: The node, if removed, would minimize M(initial): {solution.minMalwareSpread(graph, initial)}")
